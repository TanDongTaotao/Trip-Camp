# 后端骨架学习说明（成员 A 版）

目标：用 **JavaScript + Express + MongoDB Atlas + JWT + nodemon** 跑通第一阶段（Auth 三个接口），让 B/C 可以开始联调。

## 1. 怎么启动（最重要）

在 `server/` 目录执行：

```bash
npm install
npm run dev
```

启动成功后：
- 健康检查：`GET http://localhost:3000/health`
- API 基础路径：`http://localhost:3000/api/v1`

环境变量：
- `server/.env` 里需要配置 `MONGODB_URI` 与 `JWT_SECRET`
- `.env.example` 是模板
- 如需要注册管理员账号（作业联调方便），可设置：`ALLOW_ADMIN_REGISTER=true`

常见启动失败原因：
- 报错 `MONGODB_URI contains placeholder`：说明你还没把 `<username>/<password>` 换成真实账号密码
- 报错 `Could not connect to any servers`：通常是 Atlas 没把你当前公网 IP 加到白名单（Network Access 里加 `0.0.0.0/0` 开发期最省事）

## 2. 目录结构与职责

```text
server/
  package.json
  nodemon.json
  .env.example
  src/
    index.js
    app.js
    db.js
    config/
      env.js
    routes/
      index.js
      auth.js
    models/
      User.js
    middlewares/
      requireAuth.js
      requireRole.js
      notFound.js
      errorHandler.js
    utils/
      jwt.js
      password.js
      errors.js
```

## 3. 每个文件做什么（按执行链路理解）

### 3.1 入口：src/index.js

它做了 4 件事（顺序很重要）：
1) `loadEnv()`：读取 `server/.env` 写进 `process.env`
2) `connectDb()`：连接 MongoDB（Atlas）
3) `createApp()`：创建 Express 应用（中间件、路由）
4) `app.listen(port)`：开始监听端口（默认 3000）

如果你启动时报错，通常也从这里的输出开始看。

### 3.2 Web 应用：src/app.js

这个文件负责“把 Express 拼装起来”：
- `cors()`：允许前端跨域访问（开发期必备）
- `express.json()`：允许接收 JSON 请求体
- `/health`：一个最简单的健康检查
- `app.use('/api/v1', apiRouter)`：挂载所有 API 路由（统一前缀）
- `notFound`：没有匹配路由时返回 404
- `errorHandler`：统一把错误转换成 `{code,message,details?}` 的 JSON

### 3.3 数据库连接：src/db.js

只做一件事：用 `mongoose.connect(MONGODB_URI)` 连接 MongoDB。
- `MONGODB_URI` 来自 `.env`
- 连接失败会抛错，最终被 `src/index.js` 捕获并退出进程

### 3.4 环境变量：src/config/env.js

你们是小白最容易卡在“为什么读不到 .env”，所以单独封装：
- `loadEnv()`：指定从 `server/.env` 读取
- `getRequiredEnv(name)`：缺少关键变量直接报错（避免默默失败）
- `getNumberEnv(name, default)`：把端口这种字符串转数字

### 3.5 路由聚合：src/routes/index.js

所有接口路由都从这里统一挂载：
- 目前只有：`/auth` 模块
- 后续你们加酒店模块，就继续 `router.use('/hotels', hotelsRouter)` 这种方式扩展

### 3.6 认证接口：src/routes/auth.js

实现了 3 个接口：
- `POST /api/v1/auth/register`
  - 校验：username>=3、password>=6、role 只能 user/merchant
  - 写库：保存 `passwordHash`（不会存明文密码）
  - 返回：`{ token, user }`
- `POST /api/v1/auth/login`
  - 查库：按 username 找用户
  - 校验：bcrypt 比对密码
  - 返回：`{ token, user }`
- `GET /api/v1/auth/me`
  - 需要 `requireAuth` 中间件（校验 token）
  - 用 token 里的 `id` 再查一遍用户，返回 `{ user }`

这里的关键点：
- token 里只放最小信息：`{ id, role }`
- 返回的 user 是“公共字段”：`{ id, username, role }`

### 3.7 用户模型：src/models/User.js

Mongoose schema 定义了 `User` 集合结构：
- `username`：唯一（unique index）
- `passwordHash`：密码哈希
- `role`：user/merchant/admin
- timestamps：自动生成 createdAt/updatedAt

### 3.8 中间件

- `src/middlewares/requireAuth.js`
  - 从请求头读 `Authorization: Bearer <token>`
  - 校验 JWT，成功则把 payload 放在 `req.user`
  - 失败返回 401（UNAUTHORIZED）

- `src/middlewares/requireRole.js`
  - 用于后续商户/管理员接口的角色校验（403）

- `src/middlewares/notFound.js`
  - 未命中任何路由时返回 404

- `src/middlewares/errorHandler.js`
  - 把各种错误统一转成 JSON 输出（前端好处理）

### 3.9 工具

- `src/utils/password.js`
  - `hashPassword`：bcryptjs 哈希
  - `verifyPassword`：bcryptjs 比对

- `src/utils/jwt.js`
  - `signToken(payload)`：签发 7 天有效的 token
  - `verifyToken(token)`：校验 token

- `src/utils/errors.js`
  - `AppError`：你自己“主动抛的业务错误”，带 status/code/details
  - `toErrorResponse(err)`：把错误统一转换成 `{status, body}`

## 4. 用 Apifox 怎么验证

1) 注册：
- `POST /auth/register`
- body：`{ "username": "alice", "password": "Password123!", "role": "user" }`

2) 登录：
- `POST /auth/login`
- body：`{ "username": "alice", "password": "Password123!" }`
- 响应会有 token

3) me：
- `GET /auth/me`
- 请求头：`Authorization: Bearer <token>`

如果这 3 个都成功，说明：
- Express 路由正常
- MongoDB 可写可读
- JWT 鉴权链路完整

